module KeyboardControl(
    input clk,                        // higher frequency than ps2_clk
    input ps2_clk,                    // clk generated by ps2 device (10kHz-20kHz)
    input ps2_data,                   // serial data from ps2
    input clrn,                       // negative clear signal
    output reg left,                  // signal for left key
    output reg right,                 // signal for right key
    output reg down,                  // signal for down key
    output reg up                     // signal for up/rotate key
);

reg [3:0] count;        // count ps2_data bits
reg [9:0] buffer;       // store ps2_data bits
reg [2:0] ps2_clk_sync; // signal to detect posedge of ps2_clk

// scan code state regs
reg F0;
reg E0;

always @ (posedge clk) begin
    ps2_clk_sync <= { ps2_clk_sync[1:0], ps2_clk };  // detect posedge of ps2_clk
end

wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1]; // posedge of ps2_clk detected

always @ (posedge clk) begin
    if (clrn == 0) begin
        F0 <= 0; E0 <= 0;
        count <= 0;
        left <= 0; right <= 0; down <= 0; up <= 0; // Reset signals on clear
    end 
    else if (sampling) begin
        if (count == 4'd10) begin
            if ((buffer[0] == 0) &&      // start bit
                (ps2_data) &&            // stop bit
                (^buffer[9:1])) begin    // odd parity
                    case(buffer[8:1])    // keyboard scan code
                    8'hF0: begin
                        F0 <= 1;
                    end
                    8'hE0: begin
                        E0 <= 1;
                        F0 <= 0;
                    end
                    8'h75: begin // Up or Rotate
                        if(E0==1'b1 && F0==1'b1) begin
                            E0 <= 0; F0 <= 0; up <= 0;
                        end
                        else if(E0==1'b1 && F0==1'b0) begin
                            up <= 1; // detect passcode for Up/Rotate
                            E0 <= 0;
                        end
                    end
                    8'h6B: begin // Left
                        if(E0==1'b1 && F0==1'b1) begin
                            E0 <= 0; F0 <= 0; left <= 0;
                        end
                        else if(E0==1'b1 && F0==1'b0) begin
                            left <= 1; // detect passcode for Left
                            E0 <= 0;
                        end
                    end
                    8'h74: begin // Right
                        if(E0==1'b1 && F0==1'b1) begin
                            E0 <= 0; F0 <= 0; right <= 0;
                        end
                        else if(E0==1'b1 && F0==1'b0) begin
                            right <= 1; // detect passcode for Right
                            E0 <= 0;
                        end
                    end
                    8'h72: begin // Down
                        if(E0==1'b1 && F0==1'b1) begin
                            E0 <= 0; F0 <= 0; down <= 0;
                        end
                        else if(E0==1'b1 && F0==1'b0) begin
                            down <= 1; // detect passcode for Down
                            E0 <= 0;
                        end
                    end
                    default: begin
                        if (F0 == 1'b1) begin // On key release, reset signals if they were set by this key
                            left <= 0; right <= 0; down <= 0; up <= 0;
                            F0 <= 0;
                        end
                    end
                    endcase
            end  
            count <= 0; // for next
        end 
        else begin
            buffer[count] <= ps2_data;   // store ps2_data
            count <= count + 1'b1;       // count ps2_data bits
        end
    end
end

endmodule